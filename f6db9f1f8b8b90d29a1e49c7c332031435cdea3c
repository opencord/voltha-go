{
  "comments": [
    {
      "key": {
        "uuid": "f82c40d2_1e095956",
        "filename": "rw_core/core/device/agent.go",
        "patchSetId": 2
      },
      "lineNbr": 262,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2020-07-23T17:33:42Z",
      "side": 1,
      "message": "Are there cases where getDeviceWithoutLock() is invoked without the \"lock\" being held?   A caller without a lock needs to invoke the getDevice().  Once the lock is held then the agent.Device can be modified as-is.  If that\u0027s not the case then we need to make sure that no caller is invoking a getDeviceWithoutLock() if they do not have the lock.\n\nRe-introducing Clone will affect processing time as well.",
      "revId": "f6db9f1f8b8b90d29a1e49c7c332031435cdea3c",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6abcf52f_736b97b1",
        "filename": "rw_core/core/device/agent.go",
        "patchSetId": 2
      },
      "lineNbr": 262,
      "author": {
        "id": 1000107
      },
      "writtenOn": "2020-07-23T18:20:48Z",
      "side": 1,
      "message": "There are currently no places where either getDeviceWithoutLock() or getDeviceReadOnly() are called without the lock.\n\nThe problem is that, in order to process state transitions inline (the original change that this patch addresses), the lock must be released beforehand.\n\nHowever, many of these functions use the device to make requests _after_ the state transition.  The device must be cloned in such cases anyway.\n\nThe idea is to change the guarantees made with devices, to make it safe to use the returned device once the lock has been released.  (Either to return to the caller, to pass to another function, or to marshal \u0026 send.)\n\nThis is a change to locks so they have the same type of guarantees as flow/group/meter/etc. locks.\n\ncloneDeviceWithoutLock() is just a convenience to clone the device before making changes.\n\n(Let me look to see if the clone in getDevice() is still necessary...)\n\nPresumably, since the device no longer has flows/groups/meters/etc. saved internally, cloning shouldn\u0027t be computationally expensive like it was before.  (This could be optimized by manually cloning the top-level device struct only, as is done in some places with i.e. logical_ports.)\n\nI\u0027m also considering adding a \"loader\" for devices / logicalDevices, though that\u0027s outside the scope of this patch.",
      "parentUuid": "f82c40d2_1e095956",
      "revId": "f6db9f1f8b8b90d29a1e49c7c332031435cdea3c",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "43e7d2f3_acd76f04",
        "filename": "rw_core/core/device/agent.go",
        "patchSetId": 2
      },
      "lineNbr": 670,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2020-07-23T21:18:39Z",
      "side": 1,
      "message": "Since the lock is released before processTransition, another waiting routine \ncould still grab the lock  before processTransition does.  In this case what do we gain by running processTransition in the caller\u0027s thread compare to running it in its own go routine?",
      "revId": "f6db9f1f8b8b90d29a1e49c7c332031435cdea3c",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2574ca3_915bac21",
        "filename": "rw_core/core/device/agent.go",
        "patchSetId": 2
      },
      "lineNbr": 670,
      "author": {
        "id": 1000107
      },
      "writtenOn": "2020-07-23T22:56:44Z",
      "side": 1,
      "message": "The difference is that the caller will have to wait until after the the transition is complete.  (so if the caller\u0027s next action depends on any transition processing, it\u0027s guaranteed that the transition will be completed.)",
      "parentUuid": "43e7d2f3_acd76f04",
      "revId": "f6db9f1f8b8b90d29a1e49c7c332031435cdea3c",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": true
    }
  ]
}