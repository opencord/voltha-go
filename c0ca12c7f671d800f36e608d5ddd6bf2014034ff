{
  "comments": [
    {
      "key": {
        "uuid": "0c435e9f_cfa1a8e7",
        "filename": "rw_core/core/device/flow/loader.go",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2020-05-21T22:21:50Z",
      "side": 1,
      "message": "Is there one instance of each Loader type per logical device?",
      "revId": "c0ca12c7f671d800f36e608d5ddd6bf2014034ff",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d6177dc8_fc13205f",
        "filename": "rw_core/core/device/flow/loader.go",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2020-05-22T07:22:25Z",
      "side": 1,
      "message": "If this can be a common struct in a common package, then we can use it in Device too. To do this, logicalDeviceId should be changed with a more common name and the root path (logical_device here) should be inserted into Loader.\n-Same for group Loader too.\n-Meter is not stored in Device",
      "range": {
        "startLine": 33,
        "startChar": 5,
        "endLine": 33,
        "endChar": 11
      },
      "revId": "c0ca12c7f671d800f36e608d5ddd6bf2014034ff",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "61365616_b2ea0df9",
        "filename": "rw_core/core/device/flow/loader.go",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1000107
      },
      "writtenOn": "2020-05-22T14:58:03Z",
      "side": 1,
      "message": "Khen: Yes, there is one loader per type per logical device.\n\nMahir: See https://gerrit.opencord.org/#/c/18790/ which addresses this.",
      "parentUuid": "d6177dc8_fc13205f",
      "range": {
        "startLine": 33,
        "startChar": 5,
        "endLine": 33,
        "endChar": 11
      },
      "revId": "c0ca12c7f671d800f36e608d5ddd6bf2014034ff",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a6ff94b6_449c101a",
        "filename": "rw_core/core/device/flow/loader.go",
        "patchSetId": 2
      },
      "lineNbr": 45,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2020-05-21T22:21:50Z",
      "side": 1,
      "message": "Why not \"sync.Mutex\" instead of \"lock ....\".?",
      "revId": "c0ca12c7f671d800f36e608d5ddd6bf2014034ff",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2677f6f9_e28481d1",
        "filename": "rw_core/core/device/flow/loader.go",
        "patchSetId": 2
      },
      "lineNbr": 45,
      "author": {
        "id": 1000107
      },
      "writtenOn": "2020-05-22T14:58:03Z",
      "side": 1,
      "message": "I typically use `varname sync.Mutex`, which somewhat reduces the extra methods available on the struct.\n\nDoesn\u0027t make much difference in this case, the usage is entirely contained in this file.",
      "parentUuid": "a6ff94b6_449c101a",
      "revId": "c0ca12c7f671d800f36e608d5ddd6bf2014034ff",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a9ffa7cb_1730f90b",
        "filename": "rw_core/core/device/flow/loader.go",
        "patchSetId": 2
      },
      "lineNbr": 113,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2020-05-22T07:22:25Z",
      "side": 1,
      "message": "Do we really need Handle? Seems we are creating garbage by creating a Handle for one time use to reach some pointers. And caller of this method already has loader that we are returning back in Handle.",
      "range": {
        "startLine": 113,
        "startChar": 0,
        "endLine": 113,
        "endChar": 57
      },
      "revId": "c0ca12c7f671d800f36e608d5ddd6bf2014034ff",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eef79da4_76fc79d7",
        "filename": "rw_core/core/device/flow/loader.go",
        "patchSetId": 2
      },
      "lineNbr": 113,
      "author": {
        "id": 1000107
      },
      "writtenOn": "2020-05-22T14:58:03Z",
      "side": 1,
      "message": "Since handle is only allocated temporarily, it will be allocated on the stack in 99% of cases, so has minimal overhead.\n\nOn the other hand, using handle allows me to force any user to use the locking mechanism correctly, avoiding common issues.",
      "parentUuid": "a9ffa7cb_1730f90b",
      "range": {
        "startLine": 113,
        "startChar": 0,
        "endLine": 113,
        "endChar": 57
      },
      "revId": "c0ca12c7f671d800f36e608d5ddd6bf2014034ff",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2ad75e25_983137f7",
        "filename": "rw_core/core/device/flow/loader.go",
        "patchSetId": 2
      },
      "lineNbr": 137,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2020-05-21T22:21:50Z",
      "side": 1,
      "message": "Some more description about the Handle would be useful.   Is it something that gets created only for one-time use?",
      "revId": "c0ca12c7f671d800f36e608d5ddd6bf2014034ff",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1d28e5cc_2ec7b2a4",
        "filename": "rw_core/core/device/flow/loader.go",
        "patchSetId": 2
      },
      "lineNbr": 137,
      "author": {
        "id": 1000107
      },
      "writtenOn": "2020-05-22T14:58:03Z",
      "side": 1,
      "message": "A handle is allocated for each Lock() call, all modification calls are made using it, and it is invalidated on Unlock().\n\nThis enforces correct Lock()-Usage()-Unlock() ordering.\n\nThis is especially helpful for cases where multiple locks need to be held during some processing. \u003c-- Though this is not done anywhere yet.",
      "parentUuid": "2ad75e25_983137f7",
      "revId": "c0ca12c7f671d800f36e608d5ddd6bf2014034ff",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1edaccd3_63f58ad8",
        "filename": "rw_core/core/device/logical_agent_flow.go",
        "patchSetId": 2
      },
      "lineNbr": 42,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2020-05-21T22:21:50Z",
      "side": 1,
      "message": "Nothing prevents the caller of listLogicaldeviceFlows() to change the value of the flow, right?",
      "revId": "c0ca12c7f671d800f36e608d5ddd6bf2014034ff",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "40add2bd_03997c55",
        "filename": "rw_core/core/device/logical_agent_flow.go",
        "patchSetId": 2
      },
      "lineNbr": 42,
      "author": {
        "id": 1000107
      },
      "writtenOn": "2020-05-22T14:58:03Z",
      "side": 1,
      "message": "Correct.  Part of this change is to remove cloning where feasible.  This is being done by changing the guarantees made.  \n\nflows/groups/meters which are saved to Loaders MUST NOT be changed afterwards, and flows/groups/meters which are read from the loader must not be changed, but are safe to keep forever.\n\nThis is documented in the loaders.\n\ni.e. - *ofp.OfpFlowStats, *ofp.OfpMeterEntry, and *ofp.OfpGroupEntry should be treated as if they are immutable, and cloned only when modified.",
      "parentUuid": "1edaccd3_63f58ad8",
      "revId": "c0ca12c7f671d800f36e608d5ddd6bf2014034ff",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    }
  ]
}