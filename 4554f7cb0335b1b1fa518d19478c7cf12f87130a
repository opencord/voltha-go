{
  "comments": [
    {
      "key": {
        "uuid": "856aa70d_e772fe32",
        "filename": "rw_core/core/device_ownership.go",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1000107
      },
      "writtenOn": "2019-05-30T14:38:10Z",
      "side": 1,
      "message": "If DeviceOwnership is always passed as a pointer (*DeviceOwnership), then there\u0027s no reason for mutexes to be pointers.",
      "revId": "4554f7cb0335b1b1fa518d19478c7cf12f87130a",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d5f127a8_d2634001",
        "filename": "rw_core/core/device_ownership.go",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2019-05-30T14:49:50Z",
      "side": 1,
      "message": "Correct.   Will address in one of those cleanups cycle.",
      "parentUuid": "856aa70d_e772fe32",
      "revId": "4554f7cb0335b1b1fa518d19478c7cf12f87130a",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fe1da81f_2f2e549e",
        "filename": "rw_core/core/device_ownership.go",
        "patchSetId": 2
      },
      "lineNbr": 197,
      "author": {
        "id": 1000003
      },
      "writtenOn": "2019-05-30T02:20:33Z",
      "side": 1,
      "message": "Do we know the root cause of why it is called twice in rapid succession? Can we prevent that as opposed to introducing a lock?",
      "revId": "4554f7cb0335b1b1fa518d19478c7cf12f87130a",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ba6d1d2_d2a19686",
        "filename": "rw_core/core/device_ownership.go",
        "patchSetId": 2
      },
      "lineNbr": 197,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2019-05-30T02:29:07Z",
      "side": 1,
      "message": "Yes the root cause is valid.   When invoking a delete on a device and that device is not in one of the core pair then it needs to be loaded in memory.  As part of the loading the ownership of the device ownership gets set.  As this is part of a NB request then there is a check for device ownership as well.   Both of these happens in separate go routines.  This scenario happens only when deleting a device in preprovision state.",
      "parentUuid": "fe1da81f_2f2e549e",
      "revId": "4554f7cb0335b1b1fa518d19478c7cf12f87130a",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    }
  ]
}