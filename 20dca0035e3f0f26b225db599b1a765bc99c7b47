{
  "comments": [
    {
      "key": {
        "uuid": "d181b071_95aac3a0",
        "filename": "rw_core/core/logical_device_manager.go",
        "patchSetId": 2
      },
      "lineNbr": 543,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2019-10-25T15:21:23Z",
      "side": 1,
      "message": "These methods does not seem to have been tested properly.   I would actually change the logic of both methods.  Instead of getting the  logicalPort first I would pass the port id to the agent.enableLogicalPort and let that function deal with it.",
      "revId": "20dca0035e3f0f26b225db599b1a765bc99c7b47",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e99abc95_c13b0dea",
        "filename": "rw_core/core/logical_device_manager.go",
        "patchSetId": 2
      },
      "lineNbr": 543,
      "author": {
        "id": 1000526
      },
      "writtenOn": "2019-10-29T09:56:34Z",
      "side": 1,
      "message": "I looked at the approach suggested but found some minor concerns with it.\n\nFirstly, I noticed that most of the validations on valid device/port etc are being done in LogicalDeviceManager itself and LogicalDeviceAgent is invoked to perform the change thereafter. So, this validation of port is inline with other functions in LogicalDeviceManager.\n\nAlso, most of the LogicalDeviceAgent functions perform Locking (R for lookup operations and RW for change operations) as the first step. So, if we delegate check of Port # to LogicalDeviceAgent methods that would unnecessary perform RW locking of LogicalDevice even for invalid port which is non-optimal. With current approach, such a RW lock is avoided; only R Lock is performed while trying to lookup LogicalDevice through getLogicalDevice function which further invokes agent.GetLogicalDevice()\n\nKindly let me know if I am missing something.",
      "parentUuid": "d181b071_95aac3a0",
      "revId": "20dca0035e3f0f26b225db599b1a765bc99c7b47",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0db5cd9d_e57e9395",
        "filename": "rw_core/core/logical_device_manager.go",
        "patchSetId": 2
      },
      "lineNbr": 543,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2019-10-29T14:39:01Z",
      "side": 1,
      "message": "1) The validations you saw are mostly to convert from a deviceId into a logicalDeviceId which is required to get a logical device agent.  That said, it may not be consistent everywhere but that\u0027s the intent.\n\n2) In this scenario, both the getLogicalPort in ldMgr and enableLogicalPort in ldAgent go over the logical device twice.   Since the likelihood of a enableLogicalPort being called without a logical port is quite low then I would think going straight to a RW lock in this case would be better.",
      "parentUuid": "e99abc95_c13b0dea",
      "revId": "20dca0035e3f0f26b225db599b1a765bc99c7b47",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": false
    }
  ]
}