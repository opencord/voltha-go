{
  "comments": [
    {
      "key": {
        "uuid": "fb88b1c5_8c2f8f09",
        "filename": "rw_core/core/device/agent_pm_config.go",
        "patchSetId": 3
      },
      "lineNbr": 56,
      "author": {
        "id": 1000116
      },
      "writtenOn": "2021-02-26T08:27:26Z",
      "side": 1,
      "message": "do we also want a CLEARED for this one ?",
      "revId": "f1a311776f3d6be314fc7dc7715ddb672fc8565a",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ecbccd92_314d24d8",
        "filename": "rw_core/core/device/agent_pm_config.go",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-26T13:51:05Z",
      "side": 1,
      "message": "Why there is a need for synchronous for PMs? This code will block all requests (both northbound and southbound) on that device.\n\nIf the idea is to update PMs only after a successful adapter response then I suggest the following:\n\n1) Similar to the previous commit, create a onPMSuccess and onPMFailure functions.\n2) In the updatePmConfigs() method, you can either update the PmConfigs in the Device object right away and keep the older version or do not update the device object right away, i.e. update only on a successful response. There are pros and cons for both approaches - the \"update before sending to adapter\" works well if there are multiple pm requests and the successful responses from the adapter comes out of order, the \"update after sending to the adapter\" works better in that situation on failure responses.  If we will most likely get only 1 PM config update then either approach is ok.\n3) Release the lock relevant \"agent.requestQueue.WaitForGreenLight\".\n4) Use the \"go agent.waitForAdapterResponse(...)\" approach and pass in the onPMSuccess and onPMFailure functions along with the PM config data (depends on your choice in 2).",
      "revId": "f1a311776f3d6be314fc7dc7715ddb672fc8565a",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8f9610f8_67b042bd",
        "filename": "rw_core/core/device/agent_pm_config.go",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000127
      },
      "writtenOn": "2021-02-26T20:37:18Z",
      "side": 1,
      "message": "There are a few reasons I decided to make this blocking from my initial patch set which was non-blocking.\n1. The caller is not intimated about the failure (in case the update fails) of the pm update in case of async mode. It is always a success to caller, unless the caller lists the pm config to check and see whether the update has indeed happened.\n2. The pm config update is not an operation that happens a lot. It may happen a handful of times (may be once or twice) during time the ONU is provisioned. This operation is not talking to the actual device but just a config update within the adapter so it is not blocking for a long time.\n\nThe failure event is posted on kafka (in case of pm update failure), but may be returning the response on the same call is useful here, not sure.. Thoughts?",
      "parentUuid": "ecbccd92_314d24d8",
      "revId": "f1a311776f3d6be314fc7dc7715ddb672fc8565a",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ccdfaeff_8b4fae72",
        "filename": "rw_core/core/device/agent_pm_config.go",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2021-02-26T21:01:40Z",
      "side": 1,
      "message": "If there is a need for the caller to get a complete response, you can still do so while releasing the lock.  There are a few examples, e.g. getSwitchCapability(), getSingleValue() depending in the \"update after\" or \"update before\" approach.",
      "parentUuid": "8f9610f8_67b042bd",
      "revId": "f1a311776f3d6be314fc7dc7715ddb672fc8565a",
      "serverId": "2a2bfe1b-c5c2-48ed-9ac8-16438ab24388",
      "unresolved": true
    }
  ]
}